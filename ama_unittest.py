"""
Unit tests for the audio metadata auditing tool.

These tests were generated by ChatGPT 5 to cover various scenarios
for the audio metadata auditing tool. They focus on edge cases and typical usage patterns,
ensuring that the tool behaves as expected under different conditions.

Authored by ChatGPT 5 (October 2025).

Copyright: I am not claiming any copyright on this code.
"""
import io
import os
import tempfile
from pathlib import Path
import contextlib
import unittest
from unittest.mock import patch

# Import the main module to be tested
import ama as sm


def _mkfiles(root: Path, names_and_bytes):
    """Create files with provided names and byte contents."""
    paths = []
    for name, data in names_and_bytes:
        p = root / name
        p.parent.mkdir(parents=True, exist_ok=True)
        with open(p, "wb") as f:
            f.write(data)
        paths.append(p)
    return paths


class TestMusicScan(unittest.TestCase):

    # Purpose: Validate the empty-input baseline.
    # What: Asserts that a clear message is emitted when no audio files are discovered.
    # Rationale: Ensures user-facing clarity for the most common error path.
    def test_no_supported_files_returns_clear_message(self):
        with tempfile.TemporaryDirectory() as td:
            out = sm.get_output(
                root=td,
                debug_enabled=False,
                max_depth=5,
                per_album=False,
                no_quick_stats=False,
                show_progress=False,
            )
            self.assertIn("Couldn't find any music files", out)

    # Purpose: Validate directory traversal limits.
    # What: Ensures files deeper than the specified max depth are not scanned.
    # Rationale: Prevents unintended deep recursion and keeps performance predictable.
    def test_depth_limit_excludes_deep_files(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            # file deeper than depth=1
            _mkfiles(root / "a" / "b", [("deep.mp3", b"x"*10)])
            out = sm.get_output(
                root=str(root),
                debug_enabled=False,
                max_depth=1,  # should NOT reach a/b
                per_album=False,
                no_quick_stats=False,
                show_progress=False,
            )
            self.assertIn("Couldn't find any music files", out)

    # Purpose: Validate progress feedback.
    # What: Confirms the progress bar renders when enabled during scanning.
    # Rationale: Ensures long-running scans provide visible feedback.
    def test_progress_bar_paints_when_enabled(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("t1.mp3", b"a"), ("t2.flac", b"b")])

            # Patch to return minimal dicts so scanning completes.
            mapping = {
                "t1.mp3": {"file_name": "t1.mp3", "container": "mp3", "size_bytes": 1},
                "t2.flac": {"file_name": "t2.flac", "container": "flac", "size_bytes": 1},
            }
            def fake_to_uniform_dict(path):
                base = os.path.basename(path)
                d = dict(mapping[base])
                d.update({
                    "path": path,
                    "length_s": 60,
                    "sample_rate": 44100,
                    "channels": 2,
                    "bitrate": 192000,
                    "tags": {},
                    "title": base,
                    "album": "Album",
                    "artist": "Artist",
                    "artwork_hashes": set(),
                    "content_hash": base,  # unique
                })
                return d

            buf = io.StringIO()
            with patch.object(sm, "to_uniform_dict", side_effect=fake_to_uniform_dict):
                with contextlib.redirect_stdout(buf):
                    sm.scan_folder_for_audio_recursive(str(root), max_depth=5, debug_enabled=False, show_progress=True)
            s = buf.getvalue()
            self.assertIn("Scanning: [", s)
            self.assertIn("]", s)

    # Purpose: Validate multi-format detection messaging.
    # What: Ensures an informational note appears when more than one container is present.
    # Rationale: Provides useful context for mixed-format albums or folders.
    def test_info_multiple_formats(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("a.mp3", b"a"), ("b.flac", b"b")])

            def fake(path):
                base = os.path.basename(path)
                container = "mp3" if base.endswith(".mp3") else "flac"
                return {
                    "path": path,
                    "file_name": base,
                    "container": container,
                    "length_s": 30,
                    "sample_rate": 44100,
                    "channels": 2,
                    "bitrate": 192000,
                    "tags": {},
                    "title": base,
                    "album": "Same Album",
                    "artist": "Same Artist",
                    "track_number": 1,
                    "track_total": 2,
                    "id3_version": None,
                    "artwork_hashes": set(),
                    "content_hash": base,
                    "size_bytes": 100,
                }

            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("[INFO]", out)
                self.assertIn("multiple file formats", out)

    # Purpose: Validate duplicate content detection and clamped reporting.
    # What: Ensures duplicate groups are identified and long listings are summarized.
    # Rationale: Keeps reports readable for large libraries while surfacing key examples.
    def test_warn_duplicates_and_limit_message(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            files = _mkfiles(root, [
                ("a1.mp3", b"A1"), ("a2.mp3", b"A2"),
                ("b1.mp3", b"B1"), ("b2.mp3", b"B2"),
                ("c1.mp3", b"C1"), ("c2.mp3", b"C2"),
                ("d1.mp3", b"D1"),
            ])
            # Create 4 duplicate groups (A,B,C,D) by content_hash
            hash_by_base = {
                "a1.mp3": "H_A", "a2.mp3": "H_A",
                "b1.mp3": "H_B", "b2.mp3": "H_B",
                "c1.mp3": "H_C", "c2.mp3": "H_C",
                "d1.mp3": "H_D",
            }
            def fake(p):
                base = os.path.basename(p)
                return {
                    "path": p,
                    "file_name": base,
                    "container": "mp3",
                    "length_s": 10,
                    "sample_rate": 44100,
                    "channels": 2,
                    "bitrate": 128000,
                    "tags": {},
                    "title": base,
                    "album": "Dup Album",
                    "artist": "Artist",
                    "track_number": None,
                    "track_total": None,
                    "id3_version": "2.3.0",
                    "artwork_hashes": {"ART"} if base.endswith("1.mp3") else {"ART"},
                    "content_hash": hash_by_base[base],
                    "size_bytes": 100,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("[WARN]", out)
                self.assertIn("Duplicate audio content detected", out)
                # Because we have 4 groups, text should indicate some not shown
                self.assertRegex(out, r"more duplicate group\(s\) not shown")

    # Purpose: Validate basic metadata consistency.
    # What: Ensures mismatched album names and artists are detected across tracks.
    # Rationale: Album/artist uniformity is a core integrity constraint for organizing libraries.
    def test_warn_album_and_artist_inconsistency(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("t1.mp3", b"1"), ("t2.mp3", b"2")])
            def fake(p):
                base = os.path.basename(p)
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": 11, "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {},
                    "title": base,
                    "album": "Alpha" if base == "t1.mp3" else "Alpha (Deluxe)",
                    "artist": "A" if base == "t1.mp3" else "B",
                    "track_number": None, "track_total": None,
                    "id3_version": "2.3.0",
                    "artwork_hashes": set(),
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("do not all share the same album name", out)
                self.assertIn("do not all share the same artist", out)

    # Purpose: Validate artwork presence and uniformity checks.
    # What: Detects missing covers and mismatched cover hashes within the same album.
    # Rationale: Ensures visual consistency and complete metadata for media managers.
    def test_warn_artwork_absence_and_mismatch(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("1.mp3", b"1"), ("2.mp3", b"2"), ("3.mp3", b"3")])
            def fake(p):
                base = os.path.basename(p)
                tn = int(Path(base).stem)
                art = set()
                if base == "1.mp3":
                    art = {"H1"}
                elif base == "2.mp3":
                    art = {"H2"}  # different hash to trigger mismatch
                # "3.mp3" has no artwork
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": 10, "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "Art Album", "artist": "X",
                    "track_number": tn, "track_total": 3,
                    "id3_version": "2.3.0",
                    "artwork_hashes": art,
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("do not have an album cover: 3", out)
                self.assertIn("Cover artwork differs across tracks", out)

    # Purpose: Validate technical stream consistency checks.
    # What: Detects mixed sample rates and channel counts across tracks in one album.
    # Rationale: Prevents uneven playback quality and downstream processing issues.
    def test_warn_sample_rate_and_channels(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("a.mp3", b"a"), ("b.mp3", b"b")])
            def fake(p):
                base = os.path.basename(p)
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": 10, "sample_rate": 44100 if base=="a.mp3" else 48000,
                    "channels": 2 if base=="a.mp3" else 1, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "Tech Album", "artist": "X",
                    "track_number": None, "track_total": None,
                    "id3_version": "2.3.0",
                    "artwork_hashes": set(),
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("multiple sample rates", out)
                self.assertIn("multiple channel counts", out)

    # Purpose: Validate ID3 version hygiene.
    # What: Detects mixed and non-standard ID3 versions within MP3 albums.
    # Rationale: Encourages consistent tagging practices for compatibility.
    def test_warn_id3_version_inconsistency_and_invalid(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("x.mp3", b"x"), ("y.mp3", b"y")])
            def fake(p):
                base = os.path.basename(p)
                version = "2.2.0" if base == "x.mp3" else "2.3.0"
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": 10, "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "V Album", "artist": "X",
                    "track_number": None, "track_total": None,
                    "id3_version": version,
                    "artwork_hashes": set(),
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("ID3 versions are not consistent", out)
                self.assertIn("non-standard ID3 versions: 2.2.0", out)

    # Purpose: Validate critical-path reporting for invalid MP3s.
    # What: Aggregates unreadable MP3s and MP3s missing length into a CRIT summary.
    # Rationale: Highlights severe issues that likely affect playback.
    def test_crit_unreadable_mp3_or_missing_length(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("bad.mp3", b"1"), ("ok.mp3", b"2")])
            def fake(p):
                base = os.path.basename(p)
                if base == "bad.mp3":
                    return {
                        "path": p, "file_name": base, "container": "mp3",
                        "error": "mp3_unreadable", "size_bytes": 1,
                    }
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": None,  # also counted as invalid per code
                    "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "C Album", "artist": "X",
                    "track_number": None, "track_total": None,
                    "id3_version": "2.3.0",
                    "artwork_hashes": set(),
                    "content_hash": base,
                    "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("[CRIT]", out)
                self.assertRegex(out, r"\d+ MP3 file\(s\) appear unreadable or invalid")

    # Purpose: Validate the all-clear path.
    # What: Confirms that a clean report prints an explicit statement and the quick stats line.
    # Rationale: Ensures the absence of issues is communicated as clearly as their presence.
    def test_no_messages_path_prints_no_warnings_block(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("ok1.mp3", b"1"), ("ok2.mp3", b"2")])
            def fake(p):
                base = os.path.basename(p)
                return {
                    "path": p, "file_name": base, "container": "mp3",
                    "length_s": 60, "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "Clean", "artist": "Same",
                    "track_number": None, "track_total": None,
                    "id3_version": "2.3.0",
                    "artwork_hashes": {"ART"},  # identical artwork
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("No warnings, critical issues, or informational notes were detected.", out)
                self.assertIn("Albums:", out)  # quick stats present by default

    # Purpose: Validate global quick-stats toggling.
    # What: Ensures quick stats can be hidden while other sections remain available.
    # Rationale: Supports succinct output modes without sacrificing key information.
    def test_hide_quick_stats_flag(self):
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("a.mp3", b"1"), ("b.flac", b"2")])
            def fake(p):
                base = os.path.basename(p)
                container = "mp3" if base.endswith(".mp3") else "flac"
                # Mixed formats -> INFO, ensures albums printed
                return {
                    "path": p, "file_name": base, "container": container,
                    "length_s": 1, "sample_rate": 44100, "channels": 2, "bitrate": 128000,
                    "tags": {}, "title": base, "album": "AA", "artist": "BB",
                    "track_number": None, "track_total": None,
                    "id3_version": None,
                    "artwork_hashes": set(),
                    "content_hash": base, "size_bytes": 1,
                }
            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, True, False)  # no_quick_stats=True
                self.assertNotIn("Albums:", out)  # quick stats hidden
                self.assertIn("Legend", out)

    # Purpose: Validate album grouping helper behavior.
    # What: Ensures empty/None/whitespace album names fall into an "unknown" bucket,
    #       and that canonicalization produces stable keys.
    # Rationale: Guarantees deterministic grouping for downstream reporting.
    def test_group_by_album_unknown_bucket(self):
        # Directly exercise grouping helper
        files = [
            {"album": ""},  # unknown
            {"album": None},
            {"album": "  "},
            {"album": "Known"},
        ]
        grouped = sm.group_by_album(files)
        self.assertIn("unknown", grouped)
        self.assertIn("known", grouped)  # canonicalized key

    # ------------------------
    # ADDITIONAL COVERAGE
    # ------------------------

    # Purpose: Validate multi-format reporting without hard-coding a list.
    # What: Dynamically generates files for declared supported extensions and triggers
    #       the "multiple file formats" informational note via stubbing.
    # Rationale: Keeps the test aligned as supported formats evolve.
    def test_info_various_supported_formats_dynamic(self):
        """
        Dynamically generate one tiny file per supported extension (if exposed by ama),
        then stub to_uniform_dict so the reporting path for "multiple formats" is exercised.
        """
        # Try to read supported extensions from the module; fall back to a small baseline.
        exts = list(getattr(sm, "SUPPORTED_EXTS", ["mp3", "flac"]))
        # Limit the breadth to keep tests fast while still covering variety.
        exts = exts[:8] if len(exts) > 8 else exts

        if len(exts) < 2:
            self.skipTest("Need at least two supported extensions to assert 'multiple file formats'")

        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            names = [f"t{i}.{ext}" for i, ext in enumerate(exts)]
            _mkfiles(root, [(n, b"x") for n in names])

            # Map common extension quirks to canonical container names.
            def ext_to_container(ext: str) -> str:
                e = ext.lower().lstrip(".")
                if e in ("m4a", "mp4"):  # many libraries normalize m4a under mp4 atoms
                    return "mp4"
                if e in ("aif", "aiff"):
                    return "aiff"
                return e

            def fake(path):
                base = os.path.basename(path)
                ext = base.split(".")[-1]
                container = ext_to_container(ext)
                return {
                    "path": path,
                    "file_name": base,
                    "container": container,
                    "length_s": 5,
                    "sample_rate": 44100,
                    "channels": 2,
                    "bitrate": 128000,
                    "tags": {},
                    "title": base,
                    "album": "Dyn Album",
                    "artist": "Dyn Artist",
                    "track_number": None,
                    "track_total": None,
                    "id3_version": None,
                    "artwork_hashes": set(),
                    "content_hash": base,
                    "size_bytes": 1,
                }

            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                self.assertIn("[INFO]", out)
                self.assertIn("multiple file formats", out)

    # Purpose: Validate extension handling robustness.
    # What: Confirms case-insensitive extension recognition and skip behavior for unknown types.
    # Rationale: Prevents crashes on uncommon casings and unsupported files.
    def test_uppercase_extension_is_recognized_and_unknown_skipped(self):
        """
        Ensure case-insensitive extension handling (e.g., .MP3) and that unknown extensions
        are skipped safely by the scanner before parsing.
        """
        with tempfile.TemporaryDirectory() as td:
            root = Path(td)
            _mkfiles(root, [("A.MP3", b"x"), ("weird.xyz", b"y")])

            def fake(path):
                base = os.path.basename(path)
                # Only called for supported files; unknown should be skipped by the scanner.
                return {
                    "path": path,
                    "file_name": base,
                    "container": "mp3",
                    "length_s": 2,
                    "sample_rate": 44100,
                    "channels": 2,
                    "bitrate": 128000,
                    "tags": {},
                    "title": base,
                    "album": "Case Test",
                    "artist": "Artist",
                    "track_number": None,
                    "track_total": None,
                    "id3_version": None,
                    "artwork_hashes": set(),
                    "content_hash": base,
                    "size_bytes": 1,
                }

            with patch.object(sm, "to_uniform_dict", side_effect=fake):
                out = sm.get_output(str(root), False, 5, False, False, False)
                # Should have processed A.MP3 and produced a normal report (at least INFO/Legend/etc.)
                self.assertNotIn("Couldn't find any music files", out)
                self.assertTrue(any(tag in out for tag in ("[INFO]", "Legend", "Albums:", "[WARN]", "[CRIT]")))


if __name__ == "__main__":
    unittest.main()